package me.alexbakker.cve_2019_9465;

import android.content.DialogInterface;
import android.hardware.biometrics.BiometricPrompt;
import android.os.CancellationSignal;
import android.os.Handler;
import android.security.keystore.KeyGenParameterSpec;
import android.security.keystore.KeyProperties;

import androidx.appcompat.app.AlertDialog;
import androidx.appcompat.app.AppCompatActivity;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.EditText;
import android.widget.LinearLayout;
import android.widget.Switch;
import android.widget.TextView;
import android.widget.Toast;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.UnrecoverableKeyException;
import java.util.Arrays;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.ShortBufferException;
import javax.crypto.spec.GCMParameterSpec;

public class MainActivity extends AppCompatActivity {

    private final static String aad = "test.aads";
    private final static String keyAlias = "test";
    private final static int IV_SIZE_IN_BYTES = 12;
    private final static int TAG_SIZE_IN_BYTES = 16;

    private int i = 0;
    private KeyStore _keyStore;

    private boolean _isStopped = false;

    private int _timeout = 10;
    private boolean _decrypt = true;
    private boolean _userAuth = false;
    private boolean _randomNonce = true;
    private boolean _strongBox = true;

    private View _view;
    private Switch _switchAuth;
    private Switch _switchDecrypt;
    private Switch _switchNonce;
    private Switch _switchStrongBox;
    private LinearLayout _layoutTimeout;
    private EditText _textTimeout;

    private TextView _log;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        _log = findViewById(R.id.log);

        showOptionsDialog();
    }

    @Override
    protected void onStop() {
        super.onStop();
    }

    @Override
    protected void onStart() {
        super.onStart();
        _isStopped = true;
    }

    private void showOptionsDialog() {
        _view = getLayoutInflater().inflate(R.layout.dialog_options, null);
        _switchAuth = _view.findViewById(R.id.switch_auth);
        _switchDecrypt = _view.findViewById(R.id.switch_decrypt);
        _switchNonce = _view.findViewById(R.id.switch_nonce);
        _switchStrongBox = _view.findViewById(R.id.switch_strongBox);
        _layoutTimeout = _view.findViewById(R.id.layout_timeout);
        _textTimeout = _view.findViewById(R.id.text_timeout);
        _switchAuth.setChecked(_userAuth);
        _switchAuth.setOnCheckedChangeListener((buttonView, isChecked) -> {
            _layoutTimeout.setVisibility(isChecked ? View.GONE : View.VISIBLE);
        });
        _switchDecrypt.setChecked(_decrypt);
        _switchNonce.setChecked(_randomNonce);
        _switchStrongBox.setChecked(_strongBox);
        _textTimeout.setText(Integer.toString(_timeout));
        _layoutTimeout.setVisibility(_userAuth ? View.GONE : View.VISIBLE);

        new AlertDialog.Builder(this)
                .setView(_view)
                .setTitle("Options")
                .setPositiveButton(android.R.string.ok, new OptionsListener())
                .show();
    }

    private void startEncrypt() {
        //logClear();
        _log.append("\n");

        if (_isStopped) {
            log("Operation stopped");
            return;
        }

        try {
            // Acquire key
            SecretKey key = (SecretKey) _keyStore.getKey(keyAlias, null);
            Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
            cipher.init(Cipher.ENCRYPT_MODE, key);

            if (_userAuth) {
                BiometricPrompt.CryptoObject obj = new BiometricPrompt.CryptoObject(cipher);
                BiometricPrompt prompt = new BiometricPrompt.Builder(this)
                        .setTitle("Encrypt")
                        .setConfirmationRequired(false)
                        .setNegativeButton("Cancel", getMainExecutor(), (dialog, which) -> {
                        })
                        .build();

                prompt.authenticate(obj, new CancellationSignal(), getMainExecutor(), new BiometricPrompt.AuthenticationCallback() {
                    @Override
                    public void onAuthenticationSucceeded(BiometricPrompt.AuthenticationResult result) {
                        encrypt(result.getCryptoObject().getCipher());
                    }
                });
            } else {
                new Handler().postDelayed(() -> encrypt(cipher), _timeout);
            }
        } catch (Exception e) {
            logError(e);
            showOptionsDialog();
        }
    }

    private void startDecrypt(byte[] encrypted, byte[] nonce) {
        _log.append("\n");

        if (_isStopped) {
            log("Operation stopped");
            return;
        }

        try {
            SecretKey key = (SecretKey) _keyStore.getKey(keyAlias, null);
            Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
            GCMParameterSpec spec = new GCMParameterSpec(8 * TAG_SIZE_IN_BYTES, nonce, 0, IV_SIZE_IN_BYTES);
            cipher.init(Cipher.DECRYPT_MODE, key, spec);

            if (_userAuth) {
                BiometricPrompt.CryptoObject obj = new BiometricPrompt.CryptoObject(cipher);
                BiometricPrompt prompt = new BiometricPrompt.Builder(this)
                        .setTitle("Decrypt")
                        .setConfirmationRequired(false)
                        .setNegativeButton("Cancel", getMainExecutor(), (dialog, which) -> {

                        })
                        .build();

                prompt.authenticate(obj, new CancellationSignal(), getMainExecutor(), new BiometricPrompt.AuthenticationCallback() {
                    @Override
                    public void onAuthenticationSucceeded(BiometricPrompt.AuthenticationResult result) {
                        decrypt(result.getCryptoObject().getCipher(), encrypted);
                    }
                });
            } else {
                decrypt(cipher, encrypted);
                //new Handler().postDelayed(() -> decrypt(cipher, encrypted), _timeout);
            }
        } catch (NoSuchAlgorithmException | InvalidKeyException | InvalidAlgorithmParameterException | NoSuchPaddingException | KeyStoreException | UnrecoverableKeyException e) {
            logError(e);
            showOptionsDialog();
        }
    }

    private void encrypt(Cipher cipher) {
        byte[] plain = "this is a test string".getBytes(StandardCharsets.UTF_8);
        byte[] aadBytes = aad.getBytes(StandardCharsets.UTF_8);
        final byte[] ciphertext = new byte[plain.length + TAG_SIZE_IN_BYTES];
        try {
            cipher.updateAAD(aadBytes);
            cipher.doFinal(plain, 0, plain.length, ciphertext, 0);
        } catch (BadPaddingException | IllegalBlockSizeException | ShortBufferException e) {
            logError(e);
            showOptionsDialog();
            return;
        }

        byte[] tag = Arrays.copyOfRange(ciphertext, ciphertext.length - TAG_SIZE_IN_BYTES, ciphertext.length);
        log(String.format("plaintext: %s", encode(plain)));
        log(String.format("ciphertext: %s", encode(ciphertext)));
        log(String.format("tag: %s", encode(tag)));
        log(String.format("nonce: %s", encode(cipher.getIV())));

        if (_decrypt) {
            startDecrypt(ciphertext, cipher.getIV());
        } else {
            startEncrypt();
        }
    }

    private void decrypt(Cipher cipher, byte[] encrypted) {
        byte[] decrypted;
        byte[] aadBytes = aad.getBytes(StandardCharsets.UTF_8);
        try {
            cipher.updateAAD(aadBytes);
            decrypted = cipher.doFinal(encrypted);
        } catch (BadPaddingException | IllegalBlockSizeException e) {
            logError(e);
            showOptionsDialog();
            return;
        }

        log(String.format("decrypted: %s", encode(decrypted)));
        startEncrypt();
    }

    private void log(String msg) {
        Log.println(Log.DEBUG, "Main", msg);
        _log.append(msg + "\n");
    }

    private void logError(Exception e) {
        Toast.makeText(this, e.toString(), Toast.LENGTH_LONG).show();

        StringWriter sw = new StringWriter();
        e.printStackTrace(new PrintWriter(sw));
        e.printStackTrace();
        log("\n" + sw.toString());
    }

    private static String encode(byte[] a) {
        StringBuilder sb = new StringBuilder(a.length * 2);
        for (byte b : a) {
            sb.append(String.format("%02x", b));
        }
        return sb.toString();
    }

    private class OptionsListener implements DialogInterface.OnClickListener {
        @Override
        public void onClick(DialogInterface dialog, int which) {
            _userAuth = _switchAuth.isChecked();
            _decrypt = _switchDecrypt.isChecked();
            _randomNonce = _switchNonce.isChecked();
            _strongBox = _switchStrongBox.isChecked();
            _timeout = Integer.parseInt(_textTimeout.getText().toString());
            _isStopped = false;

            try {
                _keyStore = KeyStore.getInstance("AndroidKeyStore");
                _keyStore.load(null);

                // make sure the key store is empty before continuing
                if (_keyStore.containsAlias(keyAlias)) {
                    _keyStore.deleteEntry(keyAlias);
                }

                int purpose = KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT;

                KeyGenerator generator = KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES, "AndroidKeyStore");
                generator.init(new KeyGenParameterSpec.Builder(keyAlias, purpose)
                        .setBlockModes(KeyProperties.BLOCK_MODE_GCM)
                        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
                        .setRandomizedEncryptionRequired(_randomNonce)
                        .setUserAuthenticationRequired(_userAuth)
                        .setIsStrongBoxBacked(_strongBox)
                        .setKeySize(256)
                        .build());
                generator.generateKey();
            } catch (Exception e) {
                logError(e);
                showOptionsDialog();
                return;
            }

            startEncrypt();
        }
    }
}
